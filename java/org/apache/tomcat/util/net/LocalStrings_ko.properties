# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

channel.nio.ssl.appOutputNotEmpty=애플리케이션 출력 버퍼가 아직 데이터를 가지고 있습니다. 데이터를 잃을 수도 있었습니다.
channel.nio.ssl.eofDuringHandshake=handshake 하는 동안 EOF
channel.nio.ssl.invalidCloseState=유효하지 않은, 닫힘 상태입니다. 네트워크로 데이터를 전송하지 않을 것입니다.
channel.nio.ssl.notHandshaking=Handshake 중 NOT_HANDSHAKING 발생
channel.nio.ssl.remainingDataDuringClose=네트워크 버퍼에 데이터가 남아있습니다. SSL close 메시지를 보낼 수 없습니다. close(true)를 대신 사용해 강제로 닫으려 합니다.
channel.nio.ssl.sniDefault=요청된 SNI 호스트 이름을 결정하기 위한 충분한 버퍼를 생성할 수 없습니다. 기본 값을 사용합니다.
channel.nio.ssl.sniHostName=Connection [{0}](으)로부터 추출된 SNI 호스트 이름은 [{1}]입니다.
channel.nio.ssl.unexpectedStatusDuringWrap=WRAP을 위해 handshake하는 동안 예기치 않은 상태 [{0}]입니다.
channel.nio.ssl.unwrapFail=데이터를 unwrap할 수 없습니다. 유효하지 않은 결과 상태값입니다: [{0}]

endpoint.alpn.negotiated=ALPN을 사용하여 negotiated 프로토콜 [{0}]을(를) 설정함.
endpoint.apr.applyConf=OpenSSLConfCmd를 SSL context에 적용합니다.
endpoint.apr.assignConf=SSL context를 OpenSSLConfCmd context로 설정합니다.
endpoint.apr.checkConf=OpenSSLConf 검사를 수행합니다.
endpoint.apr.errMakeConf=OpenSSLConf context를 생성하지 못했습니다.
endpoint.apr.invalidSslProtocol=SSLProtocol 속성을 위해 제공된 값, [{0}], 은 유효하지 않습니다.
endpoint.apr.maxConnections.running=해당 APR 엔드포인트는 실행 중 maxConnections 설정을 지원하지 않습니다. 기존 값인 [{0}]이(가) 계속해서 사용될 것입니다.
endpoint.apr.maxConnections.unlimited=해당 APR 엔드포인트는 무제한 connection들을 지원하지 않습니다. 기존 값인 [{0}]이(가) 계속해서 사용될 것입니다.
endpoint.apr.noSslCertFile=Connector의 속성인 SSLCertificateFile은 반드시 SSL을 APR과 함께 사용할 때에만 정의되어야 합니다.
endpoint.apr.pollAddInvalid=소켓 [{0}]을(를) 해당 Poller에 추가를 시도하기에는 유효하지 않는 조건입니다.
endpoint.apr.tooManyCertFiles=AprEndpoint가 처리할 수 있는 양 보다 더 많은 인증서 파일들이 설정되었습니다.
endpoint.debug.channelCloseFail=채널을 닫는데 실패했습니다.
endpoint.debug.socket=소켓 [{0}]
endpoint.debug.socketCloseFail=소켓을 닫는 데에 실패함.
endpoint.getAttribute=[{0}]은(는) [{1}]
endpoint.init.bind=소켓 바인딩 실패: [{0}] [{1}]
endpoint.init.notavail=APR이 가용하지 않습니다.
endpoint.invalidJmxNameSslHostCert=호스트가 [{0}] 이고 인증서 타입이 [{1}]인 SSLHostConfigCertificate을 위한 유효한 JMX 객체 이름을 생성할 수 없습니다.
endpoint.jsse.noSslContext=호스트 이름 [{0}]을(를) 위한 SSLContext를 찾을 수 없습니다.
endpoint.nio.stopLatchAwaitInterrupted=이 쓰레드는 poller들이 중지되기를 기다리는 동안 중단되었습니다.
endpoint.noSslHostConfig=호스트 이름 [{0}]가 커넥터 [{1}]의 defaultSSLHostConfigName과 일치하는SSLHostConfig 요소를 찾을 수 없습니다.
endpoint.noSslHostName=해당 SSL 호스트 설정을 위해 어떤 호스트 이름도 제공되지 않았습니다.
endpoint.poll.fail=심각한 poller 실패 (poller를 재시작합니다): [{0}] [{1}]
endpoint.poll.limitedpollsize=명시된 크기 [{0}]로 poller를 생성하지 못했습니다.
endpoint.processing.fail=소켓 프로세서 실행 중 오류 발생
endpoint.sendfile.addfail=Sendfile 실패: [{0}] [{1}]
endpoint.sendfile.error=예기치 않은 sendfile 오류
endpoint.sendfileThreadStop=해당 sendfile 쓰레드가 정해진 시간 내에 종료되지 못했습니다.
endpoint.serverSocket.closeFailed=엔드포인트 [{0}]을(를) 위한 서버 소켓을 닫지 못하였습니다.
endpoint.setAttribute=[{1}]에 [{0}]을(를) 할당합니다.
endpoint.warn.executorShutdown=쓰레드 풀 [{0}]와(과) 연관된 해당 Executor는 완전히 종료되지 않았습니다. 일부 애플리케이션 쓰레드들이 아직 동작 중일 수 있습니다.
endpoint.warn.incorrectConnectionCount=부정확한 connection 개수. 동일한 소켓에 여러번의 socket.close가 호출되었음.
endpoint.warn.noLocalName=소켓 [{0}]을 위한 로컬 호스트 이름을 결정할 수 없습니다.
endpoint.warn.noLocalPort=소켓 [{0}]의 로컬 포트 번호를 결정할 수 없습니다.

jsse.ssl3=SSLv3이 명시적으로 사용 가능 상태로 설정되었습니다. 이 프로토콜은 안전하지 않은 것으로 알려져 있습니다.

sniExtractor.clientHelloTooBig=ClientHello가 단일 TLS 레코드에 존재하지 않기에 SNI 정보를 추출할 수 없습니다.

socket.apr.closed=이 connection과 연결된 소켓 [{0}]이(가) 이미 닫혀 있습니다.
socket.closed=이 connection과 연관된 해당 소켓은 이미 닫혔습니다.

sslHostConfig.certificate.notype=복수의 인증서들이 설정되었으며, 적어도 하나 이상의 인증서는 필수 속성 타입이 존재하지 않습니다.
sslHostConfig.fileNotFound=설정된 파일 [{0}]이 존재 하지 않습니다.
sslHostConfig.mismatch=[{1}](이)라는 이름의 SSLHostConfig에 프로퍼티 [{0}]이(가) 설정되었는데, 이 프로퍼티는 [{2}] 설정 문법을 위한 것이나 해당 SSLHostConfig은 [{3}] 설정 문법으로 사용되고 있습니다.
sslHostConfig.opensslconf.null=null인 OpenSSLConf를 설정하려는 시도가 무시되었습니다.
sslHostConfig.prefix_missing=프로토콜 [{0}]이(가) [{1}](이)라는 이름을 가진 SSLHostConfig의 프로토콜 목록에 추가되었습니다. +/- prefix가 결여되었는지 검사하십시오.

sslImplementation.cnfe=[{0}] 클래스의 SSLImplementation을 생성할 수 없습니다.

sslUtilBase.noneSupported=명시된 [{0}]의 어느 것도 SSL 엔진에 의해 지원되지 않습니다: [{1}]
sslUtilBase.skipped=명시된 [{0}]의 일부는 SSL 엔진에 의해 지원되지 않아 건너뜁니다: [{1}]
